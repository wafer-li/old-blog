---
title: LeetCode 笔记之——837. 新 21 点
author: Wafer Li
date: '2020-06-04 00:53'
mathjax: true
tags:
  - LeetCode
  - LeetCodeNotes
categories:
  - LeetCodeNotes
---

[题目](https://leetcode-cn.com/problems/new-21-game)

爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：

爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 `[1, W]` 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。

当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？

<!-- more -->

## 1. 题解思路

问题要求的东西，是爱丽丝最后分数的概率；

而分数，在什么时候不会变动呢？就在不能抽牌的时候！

所以，爱丽丝停止抽牌的时机点在哪？

当分数不少于 K，即分数大于等于 K 时，爱丽丝就会停止抽牌，所以最后一次抽牌的时间点就在分数等于 K - 1 时！

所以从最后一个可抽牌时机，当且仅当分数为 K - 1 时进行分析！

## 2. 以 N = 21，K = 17，W = 10 为例

此时最后一个可抽牌分数为 16；

那么，当分数为 16 的时候，再抽一张牌，所得分数不大于 21 的概率，则有：

1. 如果抽到 1，那么此时分数为 17，不能继续抽牌，显然此时 17 < 21，概率为 1
2. 如果抽到 2，那么此时分数为 18，同理，概率为 1
$\cdots$
3. 如果抽到 5，那么此时分数为 21，同理，概率为 1
3. 如果抽到 6，那么此时分数为 22，概率为 0
4. 如果抽到 7，那么此时分数为 23，概率为 0
$\cdots$
5. 如果抽到 10，那么分数为 26，概率为 0

由于抽到每一张牌的概率是**等可能的**，因此，就有：

$$
\begin{aligned}
f(16) &= \frac{1}{10} \times [1 + 1 + 1 + 1 + 1 + 0 + 0 + 0 + 0 + 0]\\
      \\
      &= 0.5
\end{aligned}
$$

那么对于 16 而言，其最终分数不大于 21 点的概率为 0.5

当分数为 15 时，爱丽丝再抽一张牌，其分数有可能变为 `[16, 25]`，那么其最终分数不大于 21 点的概率则有：

$$
\begin{aligned}
f(15) &= \frac{1}{10} \times [f(16) + 1 + 1 + 1 + 1 + 0 + 0 + 0 + 0 + 0]\\
      \\
      &= 0.5
\end{aligned}
$$

从这里，我们可以看出规律：

$$
f(x) = \frac{1}{W} \times [f(x + 1) + f(x + 2) + \cdots + f(x + W)]
$$

其中 $x$ 为 **分数**，而 $f(x)$ 则为 **当分数为 $x$ 时，最终分数不大于 $N$ 的概率**

所以，$f(0)$ 即为 **当分数为 $0$ 时，最终分数不大于 $N$ 的概率**，就是我们要求的结果。

得出方程之后，很容易就可以看出，$f(x)$ 的结果和其后面 $\mathrm{W}$ 个的结果相关；

所以，这就是一道 **动态规划** 题目！

## 3. 动态规划三板斧

### 3.1. 初始状态

K 之后的值就不变了，同时 $f(x)$ 的结果和其后面 $\mathrm{W}$ 个的结果相关；

因此，我们只需要关心 $K + W$ 个值即可；

所以，初始化 $K + W$ 长度的数组，$[K, K + W]$ 的值对应进行初始化即可

### 3.2 状态转移方程

从上面可以得到公式

### 3.3 终止状态

$x = 0$ 时，$f(x)$ 即为所求

## 4. 优化与坑点

### 4.1 更好的状态转移方程

我们看到，对于 $f(x)$ 而言，需要求解 $\mathrm{W}$ 长度的值才能得到；

如果 $\mathrm{W}$ 很大，就会导致超时。

观察 $f(x)$ 的表达式可以看出，它与 $f(x - 1)$ 是错位的：

$$
\begin{aligned}
f(x) &= \frac{1}{W} \times [f(x + 1) + f(x + 2) + \cdots + f(x + W - 1) + f(x + W)] \\
f(x - 1) &= \frac{1}{W} \times [f(x) + f(x + 1) + \cdots + f(x + W - 1)] \\
\end{aligned}
$$

因此，就可以采取 **错位相减法**，消除多余的项：

$$
\begin{aligned}
&\therefore f(x - 1) - f(x) = \frac{1}{W} \times [f(x)  - f(x + W)] \\
\\
&\therefore f(x - 1) = \frac{1}{W} \times [f(x) - f(x + W)] + f(x) \\
\end{aligned}
$$


最终我们得到的方程

$$
f(x) = \frac{1}{W} \times [f(x + 1) - f(x + W + 1)] + f(x + 1)
$$

这个方程只需要计算两项，大大减少了计算的数量。

### 4.2 $\mathrm{N}$ 和 $\mathrm{K + W}$ 之间的关系

在构造初始状态的时候，我们可以得知，在 `[K, N]` 时，概率为 1；

在 `[N, K + W - 1]` 时，概率为 0；

我相信很多人的第一反应应该是这样；

但是这里我们就犯了一个先入为主的错误，认为 $\mathrm{N}$ 一定在 $\mathrm{K}$ 和 $\mathrm{K + W - 1}$ 之间，实际上一定是这样吗？

**肯定不是！**

例如 $\mathrm{N = 10000, K = 17, W = 10}$ 时，$\mathrm{N}$ 就肯定不在 $[\mathrm{K}, \ \mathrm{K + W - 1}]$ 之间。

当 $\mathrm{N} \ge \mathrm{K + W - 1}$ 时，则对于 $\mathrm{[K, \ K+W-1]}$ 中的所有概率都为 $\mathrm{1}$；

因此，在初始化时，我们的分界点应该是

$$
\mathrm{N^\star = \min(N, K + W - 1)}
$$

### 4.3 对于 dp[K -1] 的简便求法

对于我们需要计算的第一个值，就是我们初始状态的 `dp[K - 1]`，对于这个值，我们不能套用上面优化过后的公式；

因为这个公式是一个递推式，需要通过第一个值来计算得出，那么显然我们的第一个值就是 `dp[K - 1]`；

而 `dp[K - 1]`，从例子中，我们是通过其后面的 $\mathrm{W}$ 个值计算出来的；

那么这里就有问题了，当 $\mathrm{W}$ 很大的时候，我们求解 `dp[K - 1]` 就会耗时比较长。

其实经过观察，我们可以看出，对于 `dp[K - 1]` 有:

$$
\begin{aligned}
f(K - 1) &= \frac{1}{W} \times [f(K) + f(K + 1) + \cdots + f(K + W - 1)] \\
f(K - 1) &= \frac{1}{W} \cdot \sum_{i = K}^{K + W - 1}f(i)
\end{aligned}
$$

对于 $f(i)$ 则有：

$$
\begin{aligned}
f(i) &=
\begin{cases}
1, & K \le i \le N^\star \\[2ex]
0, & N^\star \lt i \le K+W-1 \\
\end{cases}
\\[5ex]
N^\star &= \min(N, K + W - 1)
\\[5ex]
\therefore
f(K - 1) &= \frac{1}{W} \cdot \sum_{i = K}^{N^\star}f(i) \\
f(K - 1) &= \frac{1}{W} \cdot (N^\star - K + 1) \\
\end{aligned}
$$

最终，我们得到了

$$
f(K - 1) = \frac{1}{W} \cdot (N^\star - K + 1)
$$

可以在 $\mathrm{O(1)}$ 时间复杂度就求解出 `dp[K - 1]`

### 4.4 特殊情况

到现在为止，我们还没有考虑一些特殊情况，如:

1. $N \le 0$
2. $K \le 0$
3. $W \le 0$

从题目提示中，我们发现只有 $K = 0$ 是可能的，因为 $N \ge K \ge 0$ 且 $W \ge 1$

所以当 $K = 0$ 的时候，玩家不能抽牌，所得分数一定不会大于 $N$，所以此时概率为 $1$

## 5. 代码

```kotlin
class Solution {
  fun new21Game(N: Int, K: Int, W: Int): Double {
        // 0. K == 0 的特殊情况
        if (K == 0) {
            return 1.0
        }

        // 1. 初始化 K + W 个元素
        val dp = DoubleArray(K + W)

        // 2. dp[K..N*] = 1
        val spanPoint = kotlin.math.min(N, K + W - 1)
        for (i in K..spanPoint) {
            dp[i] = 1.0
        }

        // 3. 计算 dp[K - 1]
        dp[K - 1] = (1.0 / W) * (spanPoint - K + 1)

        // 4. for K-2 until 0
        ((K - 2) downTo 0).forEach {
            dp[it] = (1.0 / W) * (dp[it + 1] - dp[it + 1 + W]) + dp[it + 1]
        }

        // 5. 结果即为 dp[0]
        return dp[0]
    }
}
```
