(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{794:function(e,t,v){"use strict";v.r(t);var _=v(1),o=Object(_.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("p",[v("code",[e._v("lateinit")]),e._v(" 和 "),v("code",[e._v("lazy")]),e._v(" 是 Kotlin 中的两种不同的延迟初始化技术。")]),e._v(" "),v("p",[e._v("在 Kotlin 使用中，很可能搞不清楚它们的使用场景和方法。下面就来做一个理清：")]),e._v(" "),v("ol",[v("li",[v("code",[e._v("lateinit")]),e._v(" 只用于 "),v("code",[e._v("var")]),e._v("，而 "),v("code",[e._v("lazy")]),e._v(" 只用于 "),v("code",[e._v("val")])]),e._v(" "),v("li",[v("code",[e._v("lateinit")]),e._v(" 和 "),v("code",[e._v("lazy")]),e._v(" 都不能有 "),v("strong",[e._v("自定义的 getter 和 setter")]),e._v("，但是可以对 getter 和 setter 进行可见符修饰")]),e._v(" "),v("li",[v("code",[e._v("lazy")]),e._v(" 应用于单例模式("),v("code",[e._v("if-null-then-init-else-return")]),e._v(")，而且当且仅当变量被"),v("strong",[e._v("第一次调用")]),e._v("的时候，委托方法才会执行。")]),e._v(" "),v("li",[v("code",[e._v("lateinit")]),e._v(" 则用于只能生命周期流程中进行获取或者初始化的变量，比如 Android 的 "),v("code",[e._v("onCreate()")])]),e._v(" "),v("li",[e._v("当单例对象需要使用外界参数来进行构造时，内部的该参数对应的属性应使用 "),v("code",[e._v("lateinit")]),e._v(" "),v("blockquote",[v("p",[e._v("比如说网络 "),v("code",[e._v("ApiManager")]),e._v(" 需要 "),v("code",[e._v("context")]),e._v(" 来进行获取缓存的操作；\n那么，"),v("code",[e._v("ApiManager")]),e._v(" 中的 "),v("code",[e._v("context")]),e._v(" 属性就必须使用 "),v("code",[e._v("lateinit")])]),e._v(" "),v("p",[e._v("这是因为，"),v("code",[e._v("lazy")]),e._v(" 使用委托方法来进行变量初始化，而委托方法不能从外界获取参数，但是 "),v("code",[e._v("lateinit")]),e._v(" 可以通过一个 "),v("code",[e._v("init(context: Context)")]),e._v(" 来获取到相应的外界参数来初始化属性。")])])])])])}),[],!1,null,null,null);t.default=o.exports}}]);