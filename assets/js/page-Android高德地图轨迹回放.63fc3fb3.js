(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{955:function(e,r,v){"use strict";v.r(r);var _=v(1),t=Object(_.a)({},(function(){var e=this,r=e.$createElement,v=e._self._c||r;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("p",[e._v("最近公司要求实现一个轨迹回放功能，想着 JS 都有 demo 的功能，Android 实现起来不还是小菜一碟？")]),e._v(" "),v("p",[e._v("结果显然是我太拿衣服了")]),e._v(" "),v("h2",{attrs:{id:"_0-太长不看"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_0-太长不看"}},[e._v("#")]),e._v(" 0. 太长不看")]),e._v(" "),v("p",[e._v("全篇都采用高德 API 实现，基于 "),v("a",{attrs:{href:"https://bintray.com/bintray/jcenter/com.amap.api%3A3dmap/6.9.2",target:"_blank",rel:"noopener noreferrer"}},[v("code",[e._v("3dmap 6.9.2")]),v("OutboundLink")],1),e._v(" 包")]),e._v(" "),v("p",[e._v("使用 "),v("code",[e._v("MovingPointOverlay")]),e._v(" 实现点的平滑移动")]),e._v(" "),v("p",[e._v("使用 "),v("code",[e._v("AMap.setCustomRenderer")]),e._v(" 获取每帧回调，绘制走过的线路")]),e._v(" "),v("h2",{attrs:{id:"_1-需求分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-需求分析"}},[e._v("#")]),e._v(" 1. 需求分析")]),e._v(" "),v("p",[e._v("轨迹回放的功能在高德的 "),v("a",{attrs:{href:"https://lbs.amap.com/api/javascript-api/example/marker/replaying-historical-running-data/?sug_index=1",target:"_blank",rel:"noopener noreferrer"}},[e._v("JS Demo"),v("OutboundLink")],1),e._v(" 上有，具体来说就是点按照既定路线去移动，同时绘制其走过的路线。")]),e._v(" "),v("p",[e._v("那么我们可以将功能拆解为移动点和绘制线路")]),e._v(" "),v("p",[e._v("本来我想着这种常见的功能在网上随便搜搜就能找到的，然而显然是我太 Naive 了。")]),e._v(" "),v("p",[e._v("搜到的唯二相关的内容，其中一个排版很差，而且估计是公司内部代码，没有给出 demo，第二个则是硬怼一个自定义 View，但是地图肯定是要移动放大之类的，自定义 View 也需要做手势控制，实现难度相对较大。")]),e._v(" "),v("p",[e._v("所以最好还是在高德内部框架上实现这个需求。")]),e._v(" "),v("h2",{attrs:{id:"_2-api-调研"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-api-调研"}},[e._v("#")]),e._v(" 2. API 调研")]),e._v(" "),v("p",[e._v("经过一番查找之后，我找到了 "),v("code",[e._v("SmoothMoveMarker")]),e._v(" 可以实现点的平滑移动功能，然而：")]),e._v(" "),v("p",[v("img",{attrs:{src:"/images/android-高德地图轨迹回放/smoothmovemarker-deprecated.png",alt:"SmoothMoveMarker Deprecated"}})]),e._v(" "),v("p",[e._v("这里不得不吐槽一下高德的混淆策略，它不仅混淆了代码，同时还把文档混淆了，明明各部分文档都是公开的，将其保留在源代码里面也不会增大多少空间，然而这样全部删掉，导致我不得不切一个网页去看它的 API doc，开发效率急剧下降")]),e._v(" "),v("p",[e._v("在查看了高德地图的 API doc 之后，发现这个类是被 "),v("code",[e._v("MovingPointOverlay")]),e._v(" 替代了，也就是说我们需要采用 "),v("code",[e._v("MovingPointOverlay")]),e._v("  实现点的平滑移动")]),e._v(" "),v("h2",{attrs:{id:"_3-获取点位置回调"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-获取点位置回调"}},[e._v("#")]),e._v(" 3. 获取点位置回调")]),e._v(" "),v("p",[e._v("在 "),v("code",[e._v("MovingPointOverlay")]),e._v(" 的 "),v("a",{attrs:{href:""}},[e._v("API doc")]),e._v(" 中，有一个方法叫 "),v("code",[e._v("setMovingListener")]),e._v("，当时的我想当然的认为这个就是点移动时的回调设置方法，因此把画线的逻辑放到了里面去。")]),e._v(" "),v("p",[e._v("原先我将动画的总时间设置为 10 秒，此时点跑得比较快，乍一看没什么问题；\n但是当我将动画的时间拉长，点跑得很慢的时候，问题就出现了—— "),v("code",[e._v("setMovingListener")]),e._v(" "),v("strong",[e._v("并不是每帧回调！")])]),e._v(" "),v("p",[e._v("也就是说，只有当 Marker 跑到下一个路径点的时候，才能绘制上经过的路线！")]),e._v(" "),v("p",[e._v("这显然会导致线路绘制不平滑，达不到需求的要求。")]),e._v(" "),v("p",[e._v("那怎么办呢？这时候我就进入了一段瞎糊弄的时间，尝试着通过自行实现动画效果来完成需求，然而无论是经纬度计算、屏幕像素计算都存在误差，不太可能在短时间能将需求实现。")]),e._v(" "),v("p",[e._v("正当我想着『万策尽きた！』，无聊浏览高德地图 API doc 的时候，突然发现 "),v("code",[e._v("AMap")]),e._v(" 有个 "),v("code",[e._v("runOnDrawFrame()")]),e._v(" 方法，是用来触发高德地图的重绘的；")]),e._v(" "),v("p",[e._v("既然有这个方法，那就一定有绘制的回调方法！功夫不负有心人，在往下看了几行之后，我终于发现了这个重要的方法 "),v("code",[e._v("setCustomRenderer()")]),e._v("，而且两者意外的离的很近：")]),e._v(" "),v("p",[v("img",{attrs:{src:"/images/android-高德地图轨迹回放/runondrawframe-and-setcustomrenderer.png",alt:"runOnDrawFrame And setCustomRenderer"}})]),e._v(" "),v("p",[e._v("这个方法接受一个 "),v("code",[e._v("CustomRenderer")]),e._v(" 参数，那么什么是 "),v("code",[e._v("CustomRenderer")]),e._v(" 呢？")]),e._v(" "),v("p",[v("img",{attrs:{src:"/images/android-高德地图轨迹回放/customrenderer.png",alt:"CustomRenderer"}})]),e._v(" "),v("p",[e._v("从这里看，它有一个 "),v("code",[e._v("onDrawFrame()")]),e._v("，正是绘制每一帧的回调接口，那么我们只要将画线逻辑放到里面去就可以了。")]),e._v(" "),v("p",[e._v("当然，我们也不能抛弃 "),v("code",[e._v("setMovingListener")]),e._v("，因为我们需要它来判断是否已经到达终点。")]),e._v(" "),v("h2",{attrs:{id:"_4-实现逻辑"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-实现逻辑"}},[e._v("#")]),e._v(" 4. 实现逻辑")]),e._v(" "),v("ol",[v("li",[e._v("使用 "),v("code",[e._v("MovingPointOverlay")]),e._v(" 实现点的平滑移动")]),e._v(" "),v("li",[e._v("使用 "),v("code",[e._v("AMap.setCustomRenderer")]),e._v(" 获取每帧回调，绘制经过的线路")]),e._v(" "),v("li",[e._v("使用 "),v("code",[e._v("MovingPointOverlay.setMovingListener")]),e._v(" 判断是否已经到达终点，如果到达终点，则清除经过线路的点")])]),e._v(" "),v("h2",{attrs:{id:"_5-坑点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-坑点"}},[e._v("#")]),e._v(" 5. 坑点")]),e._v(" "),v("p",[e._v("无论是 "),v("code",[e._v("setCustomRenderer")]),e._v(" 还是 "),v("code",[e._v("setMovingListener")]),e._v("，它们的回调都是在 OPEN GL 线程回调，而"),v("strong",[e._v("不是在主线程回调")])]),e._v(" "),v("p",[e._v("因此，如果需要在动画完毕之后更改 UI，就必须使用 "),v("code",[e._v("runOnUiThread")]),e._v("，否则无论你怎么在里面更改 UI，都不会有任何效果")]),e._v(" "),v("h2",{attrs:{id:"_6-demo"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-demo"}},[e._v("#")]),e._v(" 6. Demo")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://github.com/wafer-li/AMapReplayDemo",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/wafer-li/AMapReplayDemo"),v("OutboundLink")],1)])])}),[],!1,null,null,null);r.default=t.exports}}]);