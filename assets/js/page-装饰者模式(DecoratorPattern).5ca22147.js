(window.webpackJsonp=window.webpackJsonp||[]).push([[212],{859:function(t,_,v){"use strict";v.r(_);var a=v(1),s=Object(a.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"_1-概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-概述"}},[t._v("#")]),t._v(" 1. 概述")]),t._v(" "),v("p",[t._v("装饰者模式 "),v("strong",[t._v("动态的")]),t._v(" 将责任附加到对象上。")]),t._v(" "),v("p",[t._v("若要扩展功能，装饰者提供了比继承更有弹性的解决方案")]),t._v(" "),v("h2",{attrs:{id:"_2-新的设计原则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-新的设计原则"}},[t._v("#")]),t._v(" 2. 新的设计原则")]),t._v(" "),v("p",[v("strong",[t._v("类应当对扩展开放，对修改关闭")])]),t._v(" "),v("p",[t._v("这乍看上去很矛盾，如何做到“既开放又关闭” 呢？")]),t._v(" "),v("p",[t._v("实际上，我们可以采用 "),v("strong",[t._v("组合")]),t._v(" 和 "),v("strong",[t._v("委托")]),t._v(" 来达到扩展的目的；")]),t._v(" "),v("p",[t._v("而 "),v("strong",[t._v("避免因为扩展而需要修改代码")])]),t._v(" "),v("blockquote",[v("p",[t._v("Bug 总是在修改、新增代码时引入的；\n如果能够尽量减少对代码的反复更改，那么就可以更有效的减少和避免 Bug")])]),t._v(" "),v("p",[t._v("装饰者模式就很好的体现了 “开放——关闭” 原则。")]),t._v(" "),v("h2",{attrs:{id:"_3-原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-原理"}},[t._v("#")]),t._v(" 3. 原理")]),t._v(" "),v("p",[t._v("使用不同的 "),v("strong",[t._v("装饰者对象")]),t._v(" 来对 "),v("strong",[t._v("主体对象")]),t._v(" 进行装饰；")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://i48.tinypic.com/2jabxva.jpg",alt:""}})]),t._v(" "),v("p",[t._v("通过 "),v("strong",[t._v("委托")]),t._v(" 来进行组合工作。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://i50.tinypic.com/2zrg968.jpg",alt:""}})]),t._v(" "),v("p",[t._v("这里有一个很重要的地方就是，为什么能实现上面图示的 "),v("strong",[t._v("包装")]),t._v(" 和 "),v("strong",[t._v("方法委托")])]),t._v(" "),v("p",[t._v("其使用到的技巧就是， "),v("strong",[t._v("装饰者对象实际上也是主体对象")]),t._v("，即它们有相同的超类。")]),t._v(" "),v("p",[t._v("如果不具备相同超类的话，最多只能做到一层包装，而无法做到动态的，多层包装。")]),t._v(" "),v("p",[t._v("注意，这里采用相同的超类，实际上只是为了做到 "),v("strong",[t._v("类型匹配")]),t._v("，而装饰者并没有从超类中继承它的 "),v("strong",[t._v("行为")]),t._v("。")]),t._v(" "),v("blockquote",[v("p",[t._v("继承的原罪在于， "),v("strong",[t._v("在运行时，行为需要改变！")]),t._v(" 如果行为从继承中得到，那么它在编译时就会被确定，也就是所谓的 "),v("strong",[t._v("与具体实现绑定")]),t._v("。")]),t._v(" "),v("p",[t._v("但是，如果"),v("strong",[t._v("行为不从继承中得到")]),t._v("，那么继承反而成了优点，因为继承可以实现多态，为我们的动态扩展提供合适的条件")])]),t._v(" "),v("h2",{attrs:{id:"_4-特点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-特点"}},[t._v("#")]),t._v(" 4. 特点")]),t._v(" "),v("ol",[v("li",[t._v("装饰者和被装饰对象有 "),v("strong",[t._v("相同的超类型")])]),t._v(" "),v("li",[t._v("可以使用一个或者 "),v("strong",[t._v("多个")]),t._v(" 装饰者来包装对象")]),t._v(" "),v("li",[t._v("由于有相同的超类型，所以在需要被装饰对象的场合时，可以使用装饰过后的对象来替代")]),t._v(" "),v("li",[v("strong",[t._v("装饰者可以在所委托被装饰者的行为之前、之后，加上自己的行为，以达到特定的目的")])]),t._v(" "),v("li",[t._v("对象可以在任何时候被装饰，可以在运行时，动态地、不限量地对对象进行装饰")])]),t._v(" "),v("h2",{attrs:{id:"_5-uml-图解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-uml-图解"}},[t._v("#")]),t._v(" 5. UML 图解")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://ww2.sinaimg.cn/large/65e4f1e6jw1faice8oa2nj20bq0aqwfr.jpg",alt:""}})]),t._v(" "),v("p",[t._v("可以看到，装饰者和主体对象有一个 "),v("strong",[t._v("共同的超类")])]),t._v(" "),v("p",[t._v("同时， "),v("code",[t._v("Decorator")]),t._v(" 和 "),v("code",[t._v("Component")]),t._v(" 都是 "),v("strong",[t._v("抽象类")])]),t._v(" "),v("p",[t._v("对于实际的装饰者，他们都包含了一个 "),v("code",[t._v("Component")]),t._v(" 实例，这就是被其装饰的对象，通过多态来进行方法委托。")]),t._v(" "),v("p",[t._v("图中的 "),v("code",[t._v("wrappedObject")]),t._v(" 需要从外部获得，一般来说，是通过 "),v("strong",[t._v("构造函数")]),t._v(" 传入的。")]),t._v(" "),v("h2",{attrs:{id:"_6-例子图解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-例子图解"}},[t._v("#")]),t._v(" 6. 例子图解")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://ww1.sinaimg.cn/large/006tKfTcly1fdsfoe6vu5j30nn0amgm6.jpg",alt:""}})]),t._v(" "),v("h2",{attrs:{id:"_7-真实的装饰者模式-java-io"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-真实的装饰者模式-java-io"}},[t._v("#")]),t._v(" 7. 真实的装饰者模式——Java IO")]),t._v(" "),v("p",[t._v("Java IO 库中大量使用了装饰者模式，这也就是为什么会出现如下的代码：")]),t._v(" "),v("div",{staticClass:"language-java line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[v("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("InputStream")]),t._v(" in "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("\n    "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BufferdInpuStream")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("FileInputSteram")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br")])]),v("p",[t._v("可以看到 "),v("code",[t._v("FileInputSteram")]),t._v(" 是被装饰的主体对象，而 "),v("code",[t._v("BufferdInpuStream")]),t._v(" 是装饰对象。")]),t._v(" "),v("h2",{attrs:{id:"_8-缺陷"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-缺陷"}},[t._v("#")]),t._v(" 8. 缺陷")]),t._v(" "),v("p",[t._v("装饰者对象的缺陷很明显，就是会 "),v("strong",[t._v("增加大量的小对象")]),t._v("。")]),t._v(" "),v("p",[t._v("同时，由于装饰者模式是通过 "),v("strong",[t._v("层层委托")]),t._v(" 来实现扩展的；")]),t._v(" "),v("p",[t._v("所以，当装饰者需要改变的时候，就需要将改变应用到 "),v("strong",[t._v("所有的装饰者")]),t._v("；")]),t._v(" "),v("p",[t._v("此时，当装饰者数量较多时，更改难度大。")])])}),[],!1,null,null,null);_.default=s.exports}}]);