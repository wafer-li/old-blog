(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{802:function(_,v,t){"use strict";t.r(v);var e=t(1),a=Object(e.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("p",[t("a",{attrs:{href:"#1-%E6%A6%82%E8%BF%B0"}},[_._v("1. 概述")]),t("br"),_._v(" "),t("a",{attrs:{href:"#2-%E5%85%AC%E7%BA%A6"}},[_._v("2. 公约")]),t("br"),_._v(" "),t("a",{attrs:{href:"#21-%E4%B8%80%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6"}},[_._v("2.1 一元操作符")]),t("br"),_._v(" "),t("a",{attrs:{href:"#22-%E4%BA%8C%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6"}},[_._v("2.2 二元操作符")]),t("br"),_._v(" "),t("a",{attrs:{href:"#221-%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97%E4%B8%8E%E8%8C%83%E5%9B%B4"}},[_._v("2.2.1 数学运算与范围")]),t("br"),_._v(" "),t("a",{attrs:{href:"#222-in-%E6%93%8D%E4%BD%9C%E7%AC%A6"}},[_._v("2.2.2 "),t("code",[_._v("in")]),_._v(" 操作符")]),t("br"),_._v(" "),t("a",{attrs:{href:"#223-%E6%96%B9%E6%8B%AC%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6"}},[_._v("2.2.3 方括号操作符")]),t("br"),_._v(" "),t("a",{attrs:{href:"#224-%E5%9C%86%E6%8B%AC%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6"}},[_._v("2.2.4 圆括号操作符")]),t("br"),_._v(" "),t("a",{attrs:{href:"#225-%E5%A4%8D%E5%90%88%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"}},[_._v("2.2.5 复合赋值操作")]),t("br"),_._v(" "),t("a",{attrs:{href:"#226-%E7%9B%B8%E7%AD%89%E6%80%A7%E6%A3%80%E6%9F%A5"}},[_._v("2.2.6 相等性检查")]),t("br"),_._v(" "),t("a",{attrs:{href:"#227-%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"}},[_._v("2.2.7 比较运算符")]),t("br"),_._v(" "),t("a",{attrs:{href:"#3-%E4%B8%AD%E7%BC%80%E5%87%BD%E6%95%B0"}},[_._v("3. 中缀函数")])]),_._v(" "),t("h2",{attrs:{id:"_1-概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-概述"}},[_._v("#")]),_._v(" 1. 概述")]),_._v(" "),t("p",[_._v("Kotlin 中的操作符都是由函数实现的，包括成员函数、扩展函数和中缀函数。")]),_._v(" "),t("p",[_._v("重载一个操作符，我们只要给对应的类提供一个成员函数或者扩展函数即可。")]),_._v(" "),t("p",[_._v("重载操作符的函数必须使用 "),t("code",[_._v("operator")]),_._v(" 进行标识。")]),_._v(" "),t("p",[_._v("遗憾的是，Kotlin 不支持自定义操作符，只能对现有的操作符进行重载。")]),_._v(" "),t("h2",{attrs:{id:"_2-公约"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-公约"}},[_._v("#")]),_._v(" 2. 公约")]),_._v(" "),t("p",[_._v("这里阐述的是 Kotlin 中各种操作符的对应函数和重载约定。")]),_._v(" "),t("p",[_._v("没有在以下列出的操作符，不允许被重载。")]),_._v(" "),t("blockquote",[t("p",[_._v("关于 Kotlin 中所有的操作符，请查看"),t("a",{attrs:{href:"https://kotlinlang.org/docs/reference/grammar.html#precedence",target:"_blank",rel:"noopener noreferrer"}},[_._v("这个链接"),t("OutboundLink")],1)])]),_._v(" "),t("h3",{attrs:{id:"_2-1-一元操作符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-一元操作符"}},[_._v("#")]),_._v(" 2.1 一元操作符")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("Expression")]),_._v(" "),t("th",[_._v("Translated to")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("+a")]),_._v(" "),t("td",[_._v("a.unaryPlus()")])]),_._v(" "),t("tr",[t("td",[_._v("-a")]),_._v(" "),t("td",[_._v("a.unaryMinus()")])]),_._v(" "),t("tr",[t("td",[_._v("!a")]),_._v(" "),t("td",[_._v("a.not()")])])])]),_._v(" "),t("p",[_._v("当编译时，上面的操作符会被替换为对应的函数，步骤如下:")]),_._v(" "),t("ol",[t("li",[_._v("确定 "),t("code",[_._v("a")]),_._v(" 的类型，比如 "),t("code",[_._v("T")])]),_._v(" "),t("li",[_._v("在 "),t("code",[_._v("T")]),_._v(" 中寻找方法，比如说 "),t("code",[_._v("unaryPlus()")])]),_._v(" "),t("li",[_._v("当寻找不到方法时，报错")]),_._v(" "),t("li",[_._v("如果 "),t("code",[_._v("unaryPlus()")]),_._v(" 返回类型 "),t("code",[_._v("R")]),_._v("，那么 "),t("code",[_._v("+a")]),_._v(" 的类型为 "),t("code",[_._v("R")])])]),_._v(" "),t("p",[_._v("注意，所有的操作符都会对基本类型进行优化，以减少函数调用的开支。")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("Expression")]),_._v(" "),t("th",[_._v("Translated to")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[t("code",[_._v("a++")])]),_._v(" "),t("td",[t("code",[_._v("a.inc()")]),_._v(" + see below")])]),_._v(" "),t("tr",[t("td",[t("code",[_._v("a--")])]),_._v(" "),t("td",[t("code",[_._v("a.dec()")]),_._v(" + see below")])])])]),_._v(" "),t("p",[_._v("这些操作符是用来改变它们的接收者的。")]),_._v(" "),t("blockquote",[t("p",[_._v("注意，所谓的改变接收者指的是"),t("strong",[_._v("改变其内部的值")]),_._v("，而不是改变其对象。\n事实上，应该"),t("strong",[_._v("创建并返回一个拥有新值的对象")]),_._v("，而不是对对象本身进行操作。")])]),_._v(" "),t("p",[_._v("编译器会对这样的操作符采取以下步骤的操作：")]),_._v(" "),t("ol",[t("li",[_._v("确定 "),t("code",[_._v("a")]),_._v(" 的类型 "),t("code",[_._v("T")])]),_._v(" "),t("li",[_._v("在 "),t("code",[_._v("a")]),_._v(" 中寻找 "),t("code",[_._v("inc()")]),_._v(" 方法")]),_._v(" "),t("li",[_._v("如果 "),t("code",[_._v("inc()")]),_._v(" 返回类型为 "),t("code",[_._v("R")]),_._v("，那么它必须是 "),t("code",[_._v("T")]),_._v(" 的子类")])]),_._v(" "),t("p",[_._v("对于"),t("strong",[_._v("后缀")]),_._v("操作符的计算过程如下("),t("code",[_._v("a++")]),_._v(")：")]),_._v(" "),t("ol",[t("li",[_._v("将 "),t("code",[_._v("a")]),_._v(" 的初始值存储在临时对象 "),t("code",[_._v("a0")]),_._v(" 中")]),_._v(" "),t("li",[_._v("将 "),t("code",[_._v("a.inc()")]),_._v(" 的结果赋予 "),t("code",[_._v("a")])]),_._v(" "),t("li",[_._v("返回 "),t("code",[_._v("a0")])])]),_._v(" "),t("p",[t("code",[_._v("a--")]),_._v(" 与之相同")]),_._v(" "),t("p",[_._v("对于"),t("strong",[_._v("前缀")]),_._v("操作符的计算过程如下("),t("code",[_._v("++a")]),_._v(")：")]),_._v(" "),t("ol",[t("li",[_._v("将 "),t("code",[_._v("a.inc()")]),_._v(" 的结果赋予 "),t("code",[_._v("a")])]),_._v(" "),t("li",[_._v("返回 "),t("code",[_._v("a")])])]),_._v(" "),t("h3",{attrs:{id:"_2-2-二元操作符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-二元操作符"}},[_._v("#")]),_._v(" 2.2 二元操作符")]),_._v(" "),t("h4",{attrs:{id:"_2-2-1-数学运算与范围"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1-数学运算与范围"}},[_._v("#")]),_._v(" 2.2.1 数学运算与范围")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("Expression")]),_._v(" "),t("th",[_._v("Translated to")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[t("code",[_._v("a + b")])]),_._v(" "),t("td",[t("code",[_._v("a.plus(b)")])])]),_._v(" "),t("tr",[t("td",[t("code",[_._v("a - b")])]),_._v(" "),t("td",[t("code",[_._v("a.minus(b)")])])]),_._v(" "),t("tr",[t("td",[t("code",[_._v("a * b")])]),_._v(" "),t("td",[t("code",[_._v("a.times(b)")])])]),_._v(" "),t("tr",[t("td",[t("code",[_._v("a / b")])]),_._v(" "),t("td",[t("code",[_._v("a.div(b)")])])]),_._v(" "),t("tr",[t("td",[t("code",[_._v("a % b")])]),_._v(" "),t("td",[t("code",[_._v("a.mod(b)")])])]),_._v(" "),t("tr",[t("td",[t("code",[_._v("a..b")])]),_._v(" "),t("td",[t("code",[_._v("a.rangeTo(b)")])])])])]),_._v(" "),t("p",[_._v("这些操作符在执行时会自动翻译成相应的函数执行。")]),_._v(" "),t("h4",{attrs:{id:"_2-2-2-in-操作符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-2-in-操作符"}},[_._v("#")]),_._v(" 2.2.2 "),t("code",[_._v("in")]),_._v(" 操作符")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("Expression")]),_._v(" "),t("th",[_._v("Translated to")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[t("code",[_._v("a in b")])]),_._v(" "),t("td",[t("code",[_._v("b.contains(a)")])])]),_._v(" "),t("tr",[t("td",[t("code",[_._v("a !in b")])]),_._v(" "),t("td",[t("code",[_._v("!b.contains(a)")])])])])]),_._v(" "),t("p",[_._v("对于这些方法，执行的步骤一样，但是只不过把调用关系颠倒了过来。")]),_._v(" "),t("h4",{attrs:{id:"_2-2-3-方括号操作符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-3-方括号操作符"}},[_._v("#")]),_._v(" 2.2.3 方括号操作符")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("Symbol")]),_._v(" "),t("th",[_._v("Translated to")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[t("code",[_._v("a[i]")])]),_._v(" "),t("td",[t("code",[_._v("a.get(i)")])])]),_._v(" "),t("tr",[t("td",[t("code",[_._v("a[i, j]")])]),_._v(" "),t("td",[t("code",[_._v("a.get(i, j)")])])]),_._v(" "),t("tr",[t("td",[t("code",[_._v("a[i_1, ..., i_n]")])]),_._v(" "),t("td",[t("code",[_._v("a.get(i_1, ..., i_n)")])])]),_._v(" "),t("tr",[t("td",[t("code",[_._v("a[i] = b")])]),_._v(" "),t("td",[t("code",[_._v("a.set(i, b)")])])]),_._v(" "),t("tr",[t("td",[t("code",[_._v("a[i, j] = b")])]),_._v(" "),t("td",[t("code",[_._v("a.set(i, j, b)")])])]),_._v(" "),t("tr",[t("td",[t("code",[_._v("a[i_1, ..., i_n] = b")])]),_._v(" "),t("td",[t("code",[_._v("a.set(i_1, ..., i_n, b)")])])])])]),_._v(" "),t("p",[_._v("方括号操作符的对应方法为 "),t("code",[_._v("get()")]),_._v("，根据参数个数来调用不同的 "),t("code",[_._v("get()")]),_._v(" 方法，如果有赋值操作则调用 "),t("code",[_._v("set()")]),_._v(" 方法。")]),_._v(" "),t("h4",{attrs:{id:"_2-2-4-圆括号操作符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-4-圆括号操作符"}},[_._v("#")]),_._v(" 2.2.4 圆括号操作符")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("Symbol")]),_._v(" "),t("th",[_._v("Translated to")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[t("code",[_._v("a()")])]),_._v(" "),t("td",[t("code",[_._v("a.invoke()")])])]),_._v(" "),t("tr",[t("td",[t("code",[_._v("a(i)")])]),_._v(" "),t("td",[t("code",[_._v("a.invoke(i)")])])]),_._v(" "),t("tr",[t("td",[t("code",[_._v("a(i, j)")])]),_._v(" "),t("td",[t("code",[_._v("a.invoke(i, j)")])])]),_._v(" "),t("tr",[t("td",[t("code",[_._v("a(i_1, ..., i_n)")])]),_._v(" "),t("td",[t("code",[_._v("a.invoke(i_1, ..., i_n)")])])])])]),_._v(" "),t("p",[_._v("圆括号操作符会根据参数调用相应的 "),t("code",[_._v("invoke()")]),_._v(" 方法")]),_._v(" "),t("h4",{attrs:{id:"_2-2-5-复合赋值操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-5-复合赋值操作"}},[_._v("#")]),_._v(" 2.2.5 复合赋值操作")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("Expression")]),_._v(" "),t("th",[_._v("Translated to")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[t("code",[_._v("a += b")])]),_._v(" "),t("td",[t("code",[_._v("a.plusAssign(b)")])])]),_._v(" "),t("tr",[t("td",[t("code",[_._v("a -= b")])]),_._v(" "),t("td",[t("code",[_._v("a.minusAssign(b)")])])]),_._v(" "),t("tr",[t("td",[t("code",[_._v("a *= b")])]),_._v(" "),t("td",[t("code",[_._v("a.timesAssign(b)")])])]),_._v(" "),t("tr",[t("td",[t("code",[_._v("a /= b")])]),_._v(" "),t("td",[t("code",[_._v("a.divAssign(b)")])])]),_._v(" "),t("tr",[t("td",[t("code",[_._v("a %= b")])]),_._v(" "),t("td",[t("code",[_._v("a.modAssign(b)")])])])])]),_._v(" "),t("p",[_._v("对于复合赋值操作，编译器做以下处理("),t("code",[_._v("a += b")]),_._v(")：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("如果右边一列中的函数在类中存在，那么：")]),_._v(" "),t("ul",[t("li",[_._v("检查对应的二元函数是否存在，比如 "),t("code",[_._v("plus()")]),_._v(" 对应 "),t("code",[_._v("plusAssign()")]),_._v("，如果存在，报错")]),_._v(" "),t("li",[_._v("检查函数的返回值是否为 "),t("code",[_._v("Unit")]),_._v("，如果不是，报错")]),_._v(" "),t("li",[_._v("上面检查通过后，生成相应代码")])])]),_._v(" "),t("li",[t("p",[_._v("如果右边一列中的函数在类中不存在，那么"),t("strong",[_._v("尝试生成 "),t("code",[_._v("a = a + b")])]),_._v("，包括类型检查（"),t("code",[_._v("a + b")]),_._v(" 的返回值必须是 "),t("code",[_._v("A")]),_._v(" 或其子类型）")])])]),_._v(" "),t("blockquote",[t("p",[_._v("不允许 "),t("code",[_._v("plus()")]),_._v(" 和 "),t("code",[_._v("plusAssign()")]),_._v(" 同时存在的原因：\n这是因为编译器会默认转为 "),t("code",[_._v("a = a + b")]),_._v(" 进行处理，所以当存在 "),t("code",[_._v("plus()")]),_._v(" 时，就没必要编写重复代码。")])]),_._v(" "),t("p",[_._v("需要注意的是，复合赋值是赋值语句的一种，而在 Kotlin 中，\n"),t("strong",[_._v("赋值不是一个表达式")])]),_._v(" "),t("p",[_._v("这主要是为了避免赋值语句和单行函数的冲突")]),_._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("fun attachView(view: View) = this.view = view\n")])]),_._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[_._v("1")]),t("br")])]),t("p",[_._v("上面的代码出现了二义性。")]),_._v(" "),t("p",[_._v("但是在 Java 中，赋值是一种表达式，也就是说 Java 允许")]),_._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("int a = 1, b = 1, c = 1;\nif ((a = b) != c) {\n    ....\n}\n")])]),_._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[_._v("1")]),t("br"),t("span",{staticClass:"line-number"},[_._v("2")]),t("br"),t("span",{staticClass:"line-number"},[_._v("3")]),t("br"),t("span",{staticClass:"line-number"},[_._v("4")]),t("br")])]),t("p",[_._v("而 Kotlin 只能将赋值语句移到括号外。")]),_._v(" "),t("blockquote",[t("p",[t("a",{attrs:{href:"http://stackoverflow.com/questions/36879236/how-to-convert-java-assignment-expression-to-kotlin",target:"_blank",rel:"noopener noreferrer"}},[_._v("这个链接"),t("OutboundLink")],1),_._v("中还有更多方法")])]),_._v(" "),t("h4",{attrs:{id:"_2-2-6-相等性检查"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-6-相等性检查"}},[_._v("#")]),_._v(" 2.2.6 相等性检查")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("Expression")]),_._v(" "),t("th",[_._v("Translated to")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[t("code",[_._v("a == b")])]),_._v(" "),t("td",[t("code",[_._v("a?.equals(b) ?: b === null")])])]),_._v(" "),t("tr",[t("td",[t("code",[_._v("a != b")])]),_._v(" "),t("td",[t("code",[_._v("!(a?.equals(b) ?: b === null)")])])])])]),_._v(" "),t("p",[_._v("相等性检查只需要提供 "),t("code",[_._v("equals()")]),_._v(" 方法即可。")]),_._v(" "),t("p",[_._v("注意：引用相等性检查 "),t("code",[_._v("===")]),_._v(" 和 "),t("code",[_._v("!==")]),_._v(" 是不允许重载的。")]),_._v(" "),t("p",[_._v("相等性检查被转换成如此复杂的表达式是为了筛选 "),t("code",[_._v("null")]),_._v(" 值，而且保证 "),t("code",[_._v("null == null")]),_._v(" 返回 "),t("code",[_._v("true")])]),_._v(" "),t("h4",{attrs:{id:"_2-2-7-比较运算符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-7-比较运算符"}},[_._v("#")]),_._v(" 2.2.7 比较运算符")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("Symbol")]),_._v(" "),t("th",[_._v("Translated to")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[t("code",[_._v("a > b")])]),_._v(" "),t("td",[t("code",[_._v("a.compareTo(b) > 0")])])]),_._v(" "),t("tr",[t("td",[t("code",[_._v("a < b")])]),_._v(" "),t("td",[t("code",[_._v("a.compareTo(b) < 0")])])]),_._v(" "),t("tr",[t("td",[t("code",[_._v("a >= b")])]),_._v(" "),t("td",[t("code",[_._v("a.compareTo(b) >= 0")])])]),_._v(" "),t("tr",[t("td",[t("code",[_._v("a <= b")])]),_._v(" "),t("td",[t("code",[_._v("a.compareTo(b) <= 0")])])])])]),_._v(" "),t("p",[_._v("所有的比较运算符都会被转换成 "),t("code",[_._v("compareTo()")]),_._v(" 方法；\n"),t("code",[_._v("compareTo()")]),_._v(" 方法必须返回一个 "),t("code",[_._v("Int")]),_._v(" 值。")]),_._v(" "),t("h2",{attrs:{id:"_3-中缀函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-中缀函数"}},[_._v("#")]),_._v(" 3. 中缀函数")]),_._v(" "),t("p",[_._v("除此之外，我们还可以通过定义中缀函数来定义新的**“运算符”**")]),_._v(" "),t("p",[_._v("比如数字类型的位运算就是通过中缀函数实现的。")])])}),[],!1,null,null,null);v.default=a.exports}}]);