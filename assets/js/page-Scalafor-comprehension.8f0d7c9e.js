(window.webpackJsonp=window.webpackJsonp||[]).push([[137],{825:function(a,s,t){"use strict";t.r(s);var e=t(1),v=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p",[a._v("Scala 作为函数式语言，提供了很多用于高阶函数来解决一类范式问题；")]),a._v(" "),t("p",[a._v("但是，使用过多的高阶函数就会让代码的可读性变差；")]),a._v(" "),t("p",[a._v("所以，对此 Scala 提供了一种类 Python 的简便的语法糖，用来解决代码的可读性问题。")]),a._v(" "),t("h2",{attrs:{id:"_1-问题背景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-问题背景"}},[a._v("#")]),a._v(" 1. 问题背景")]),a._v(" "),t("p",[a._v("在这里举一个 "),t("em",[a._v("Effective Scala")]),a._v(" 中的例子：")]),a._v(" "),t("p",[a._v("比如说，我要列出所有不同字母组成的 "),t("code",[a._v("pair")]),a._v("，那么该怎么办呢？")]),a._v(" "),t("p",[a._v("如果用 Java 的话，就会有两层 "),t("code",[a._v("for")]),a._v("，那么在 Scala 下，我们就应该用到 "),t("code",[a._v("flatMap")]),a._v("：")]),a._v(" "),t("div",{staticClass:"language-scala line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-scala"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("val")]),a._v(" chars "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'a'")]),a._v(" to "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'z'")]),a._v("\n\nchars flatMap "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v(" a "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("=>")]),a._v("\n    chars flatMap "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v(" b "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("=>")]),a._v("\n        Vector"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"%c%c"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("format"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" b"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v(" filter "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v(" s "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("=>")]),a._v(" s"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("head "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("!=")]),a._v(" s"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("last "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br")])]),t("p",[a._v("这里用到了两个 "),t("code",[a._v("flatMap")]),a._v("，为什么？")]),a._v(" "),t("p",[a._v("首先，如果都使用 "),t("code",[a._v("map")]),a._v("，那么内部的 "),t("code",[a._v("map")]),a._v(" 将元素转变为了 "),t("code",[a._v("Vector")]),a._v("；")]),a._v(" "),t("p",[a._v("而 "),t("code",[a._v("char")]),a._v(" 作为 "),t("code",[a._v("Range")]),a._v("，会默认选择 "),t("code",[a._v("Vector")]),a._v(" 作为 "),t("code",[a._v("map")]),a._v(" 的选项；")]),a._v(" "),t("p",[a._v("此时， "),t("code",[a._v("a")]),a._v(" 转换成的东西就变成了 "),t("code",[a._v("Vector[Vector[String]]")]),a._v("；")]),a._v(" "),t("p",[a._v("而 "),t("code",[a._v("chars")]),a._v(" 又会默认生成一层 "),t("code",[a._v("Vector")]),a._v("；")]),a._v(" "),t("p",[a._v("所以，最后生成的东西就会有三层 "),t("code",[a._v("Vector")]),a._v("，即 "),t("code",[a._v("Vector[Vector[Vector(String)]]")]),a._v("；")]),a._v(" "),t("p",[a._v("所以，我们需要两次 "),t("code",[a._v("flatten")]),a._v(" 进行展平，才能最终得到 "),t("code",[a._v("Vector(String)")]),a._v("；")]),a._v(" "),t("p",[a._v("这也是为什么需要两次 "),t("code",[a._v("flatMap")]),a._v(" 的原因。")]),a._v(" "),t("p",[a._v("可以看到，如果采用 "),t("code",[a._v("flatMap")]),a._v("，那么操作就会变得十分难以理解。")]),a._v(" "),t("h2",{attrs:{id:"_2-for-comprehension"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-for-comprehension"}},[a._v("#")]),a._v(" 2. "),t("code",[a._v("for-comprehension")])]),a._v(" "),t("p",[a._v("对此，Scala 提供了一种简便的，用于生成 "),t("code",[a._v("Seq")]),a._v(" 的 "),t("code",[a._v("for")]),a._v(" 表达式；")]),a._v(" "),t("p",[a._v("通常称为 "),t("code",[a._v("for-comprehension")]),a._v("，也称为 "),t("code",[a._v("Sequence Comprehension")]),a._v("，或者 "),t("code",[a._v("for expression")]),a._v("。")]),a._v(" "),t("p",[a._v("它的语法结构如下：")]),a._v(" "),t("div",{staticClass:"language-scala line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-scala"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("for")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("s"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("yield")]),a._v(" e\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("p",[a._v("其中，"),t("code",[a._v("s")]),a._v(" 被称作 "),t("code",[a._v("enumerators")]),a._v("，"),t("code",[a._v("e")]),a._v(" 则是遍历生成的元素；")]),a._v(" "),t("p",[a._v("表达式对于 "),t("code",[a._v("s")]),a._v(" 有以下几点要求：")]),a._v(" "),t("ol",[t("li",[t("p",[t("code",[a._v("s")]),a._v(" 是 "),t("code",[a._v("generator")]),a._v(" 和 "),t("code",[a._v("filter")]),a._v(" 组成的，以分号间隔的语句序列。")])]),a._v(" "),t("li",[t("p",[t("code",[a._v("genrator")]),a._v(" 的形式为： "),t("code",[a._v("p <- c")]),a._v("。")]),a._v(" "),t("blockquote",[t("p",[a._v("其中 "),t("code",[a._v("p")]),a._v(" 是一个模式(pattern)，"),t("code",[a._v("c")]),a._v("  则是一个集合")])])]),a._v(" "),t("li",[t("p",[t("code",[a._v("filter")]),a._v(" 的形式为 "),t("code",[a._v("if condition")]),a._v("，其中 "),t("code",[a._v("condition")]),a._v(" 是个布尔表达式")])]),a._v(" "),t("li",[t("p",[a._v("允许多个 "),t("code",[a._v("generator")]),a._v("，但是在下面的 "),t("code",[a._v("generator")]),a._v(" 必须比在上面的要变化的快。")]),a._v(" "),t("blockquote",[t("p",[a._v("换成指令性语言的话，就是在下面的 "),t("code",[a._v("generator")]),a._v(" 必须在更内部的 "),t("code",[a._v("for")]),a._v(" 循环中。")])])])]),a._v(" "),t("p",[a._v("经过执行之后，这个表达式会返回一个由 "),t("code",[a._v("e")]),a._v(" 组成的集合；")]),a._v(" "),t("p",[a._v("具体返回的集合类型，例如 "),t("code",[a._v("List")]),a._v(" 和 "),t("code",[a._v("Vector")]),a._v("，则由 "),t("code",[a._v("s")]),a._v(" 来决定；")]),a._v(" "),t("p",[a._v("如果类型不能满足，则会向类型结构的上一层回溯，直到找到一个最接近的满足要求的类型为止。")]),a._v(" "),t("p",[a._v("同时，"),t("code",[a._v("for-comprehension")]),a._v(" 可以使用花括号代替圆括号，此时，就不需要用分号来分隔语句了。")]),a._v(" "),t("h2",{attrs:{id:"_3-使用-for-comprehension-解决问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-使用-for-comprehension-解决问题"}},[a._v("#")]),a._v(" 3. 使用 "),t("code",[a._v("for-comprehension")]),a._v(" 解决问题")]),a._v(" "),t("p",[a._v("那么，对于上面的问题，我们试着使用 "),t("code",[a._v("for-comprehension")]),a._v(" 来解决：")]),a._v(" "),t("div",{staticClass:"language-scala line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-scala"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("val")]),a._v(" chars "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'a'")]),a._v(" to "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'z'")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("for")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    a "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("<-")]),a._v(" chars\n    b "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("<-")]),a._v(" chars\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("a "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("!=")]),a._v(" b"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("yield")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"%c%c"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("format"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" b"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br")])]),t("p",[a._v("可以看到，使用 "),t("code",[a._v("for-comprehension")]),a._v(" 来解决，写出来的代码会比 "),t("code",[a._v("flatMap")]),a._v(" 简单得多。")]),a._v(" "),t("h2",{attrs:{id:"_4-关于返回类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-关于返回类型"}},[a._v("#")]),a._v(" 4. 关于返回类型")]),a._v(" "),t("p",[a._v("对于上面的表达式，它的返回类型是什么呢？")]),a._v(" "),t("p",[a._v("实际上，是一个 "),t("code",[a._v("Vector")]),a._v("。")]),a._v(" "),t("p",[a._v("为什么是一个 "),t("code",[a._v("Vector")]),a._v(" ？")]),a._v(" "),t("p",[a._v("这是因为，"),t("code",[a._v("chars")]),a._v(" 实际上是一个 "),t("code",[a._v("Range")]),a._v(" 对象；")]),a._v(" "),t("p",[a._v("而对于 "),t("code",[a._v("Range")]),a._v(" 对象，它不能拥有一堆 "),t("code",[a._v("String")]),a._v("；")]),a._v(" "),t("p",[a._v("此时，Scala 编译器会在类型结构中向上寻找最近的满足条件的类型；")]),a._v(" "),t("p",[a._v("此时，寻找到的是 "),t("code",[a._v("IndexedSeq")]),a._v("，而这个类型的默认 "),t("code",[a._v("Seq")]),a._v(" 实现就是 "),t("code",[a._v("Vector")])])])}),[],!1,null,null,null);s.default=v.exports}}]);